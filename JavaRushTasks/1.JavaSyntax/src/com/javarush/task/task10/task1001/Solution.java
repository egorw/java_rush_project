package com.javarush.task.task10.task1001;

/* 
Задача №1 на преобразование целых типов
*/

public class Solution {
    public static void main(String[] args) {
        int a = 0;
        int b = (byte) a + 46; // b=46
        byte c = (byte) (a * b); // c=0
        double f = (char) 1234.15; // f = 1234
        long d = (char) (a + f / c + b);
        System.out.println(d);
    }
}
/*
  int a = 0;                          //a=0
  int b = (byte) a + 46;              //b=(byte)0+46=0+46=46
  byte c = (byte) (a*b);              //c=(byte)(0*46)=(byte)0=0
  double f = (char) 1234.15;          //f=(double)((char)1234.15)=
                                         =(double)1234=1234.0
  long d = (short) (a + f / c + b);   //d=(short)(0+(1234.0/0)+46)=
                                         =(short)(0+(бесконечность)+46)=
                                         =(short)бесконечность=-1
   Бесконечность - стандартное значение для вещественных чисел при делении на 0. А "-1"
при преобразовании бесконечности в short получается,
по видимому, из-за особенностей внутренней реализации.
 */

/*
   Здесь деление типа double на 0 приводит к результату -1. char(-1)==65535. Больше ничего менять не нужно.
Как верно указал some8uddy, "Бесконечность - стандартное значение для вещественных чисел при делении на 0".
Она может быть отрицательной и положительной. Вторая в данном случае.
Чтобы привести +бесконечность к short Джава сначала приводит число к максимальному int (011...11111, ноль и 31 единица в битовом виде,
Ноль значит положительное число). Так как это число не вмещается в short,
Джава просто отбрасываем старшие (левые )биты, чтобы осталось 16 битов (максимум для short).
У нас остается число из 16 единиц.
А тут самое интересное. Отрицательные числа хранятся не так, как положительные. И все единицы означают -1.
 */